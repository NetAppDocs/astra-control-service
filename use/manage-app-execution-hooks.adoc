---
sidebar: sidebar
permalink: use/manage-app-execution-hooks.html
keywords: execution hook, hook, script, snapshot, backup, freeze, thaw, database
summary: An execution hook is a custom script that you can run before or after a snapshot of a managed app.
---

= Manage app execution hooks
:hardbreaks:
:icons: font
:imagesdir: ../media/use/

[.lead]
An execution hook is a custom script that you can run before or after a snapshot of a managed app. For example, if you have a database app, you can use execution hooks to pause all database transactions before a snapshot, and resume transactions after the snapshot is complete. This ensures application-consistent snapshots.

For the following validated apps, Astra Control comes with default execution hooks that handle freeze and thaw operations before and after snapshots.

* MariaDB
* MySQL
* PostgreSQL

You can use the NetApp-provided hooks for these apps, or disable them and use your own. You cannot delete or modify NetApp-provided execution hooks.

== Important notes about execution hooks
Keep the following points in mind when planning execution hooks for your apps.

* Astra Control uses execution hook settings and any matching criteria to determine which hooks are applicable to a snapshot.
* All execution hook failures are soft failures; other hooks and the snapshot are still attempted even if a hook fails. However, when a hook fails, a warning event is recorded in the *Activity* page event log.
* Any executable script is supported and execution is dependent on support for that script in the container (including interpreted languages such as Python, Ruby, or Go).
* Script size is limited to 128KB.
* All create / edit / delete operations use Owner/Admin permissions.
* Scripts that run with Member and Viewer privileges can view only.

When a snapshot is run, execution hook events take place in the following order:

. Any applicable NetApp-provided pre-snapshot execution hooks are run on the appropriate containers.
. Any applicable custom pre-snapshot execution hooks are run on the appropriate containers. You can create and run as many custom pre-snapshot hooks as you need, but the order of execution of these hooks before the snapshot is neither guaranteed nor configurable.
. The snapshot is performed.
. Any applicable custom post-snapshot execution hooks are run on the appropriate containers. You can create and run as many custom post-snapshot hooks as you need, but the order of execution of these hooks after the snapshot is neither guaranteed nor configurable.
. Any applicable NetApp-provided post-snapshot execution hooks are run on the appropriate containers.

NOTE: You should always test your execution hook scripts before enabling them in a production environment. After you enable them in a production environment, test the resulting snapshots to ensure they are consistent. You can do this by cloning the app to a temporary namespace, restoring the snapshot, and then testing the app.

== View existing execution hooks
You can view existing custom or NetApp-provided execution hooks for an app.

.Steps

. Go to *Apps* and then click the name of a managed app.
. Click the *Execution hooks* tab.
+
You can view all enabled or disabled execution hooks in the resulting list. You can see a hook's status, source, and when it runs (pre- or post-snapshot). To view event logs surrounding execution hooks, go to the *Activity* page in the left-side navigation area.

== Create a custom execution hook
You can create a custom execution hook for an app.

.Steps

. Click *Apps* and then click the name of a managed app.
. Click the *Execution hooks* tab.
. Click *Add a new hook*.
. Depending on when the hook should run, choose *Pre-Snapshot* or *Post-Snapshot*.
. Enter a unique name for the hook.
. (Optional) Enter any arguments to pass to the hook during execution.
. (Optional) Enter any container image names the hook should run for. This instructs the hook to act only on the specified snapshot images.
+
An execution hook can run against all container images contained within the application (default), or you can specify a specific container image name or names here.
. Do one of the following:
* Upload a custom script.
.. Select the *Upload file* option.
.. Browse to a file and upload it.
.. Give the script a unique name.
.. (Optional) Enter any notes other administrators should know about the script.
* Paste in a custom script from the clipboard
.. Select the *Paste from clipboard* option.
.. Click the text field and paste the script text into the field.
.. Give the script a unique name.
.. (Optional) Enter any notes other administrators should know about the script.
. Click *Add hook*.

== Disable an execution hook
You can disable an execution hook if you want to temporarily prevent it from running before or after a snapshot of an app.

.Steps

. Click *Apps* and then click the name of a managed app.
. Click the *Execution hooks* tab.
. Select the *Actions* dropdown for a hook that you wish to disable.
. Select *Disable*.

== Delete an execution hook
You can remove an execution hook entirely if you no longer need it.

.Steps

. Click *Apps* and then click the name of a managed app.
. Click the *Execution hooks* tab.
. Select the *Actions* dropdown for a hook that you wish to delete.
. Select *Delete*.

=== Execution hook examples
Use the following examples to get an idea of how to structure your execution hooks.

.Pre-snapshot / post-snapshot script example
The following script demonstrates how the same script can be used for both a pre-snapshot and a post-snapshot hook.
[source,sh]
----
#!/bin/sh
#
# success_sample_pre_post.sh
#
# A simple success hook script example with an arg for testing purposes
# to demonstrate how the same script can be used for both a prehook and posthook
#
# args: [pre|post]

# unique error codes for every error case
ebase=100
eusage=$((ebase+1))
ebadstage=$((ebase+2))
epre=$((ebase+3))
epost=$((ebase+4))


#
# Writes the given message to standard output
#
# $* - The message to write
#
msg() {
    echo "$*"
}


#
# Writes the given information message to standard output
#
# $* - The message to write
#
info() {
    msg "INFO: $*"
}

#
# Writes the given error message to standard error
#
# $* - The message to write
#
error() {
    msg "ERROR: $*" 1>&2
}


#
# Would run prehook steps here
#
prehook() {
    info "Running noop prehook"
    return 0
}

#
# Would run posthook steps here
#
posthook() {
    info "Running noop posthook"
    return 0
}


#
# main
#

# check arg
stage=$1
if [ -z "${stage}" ]; then
    echo "Usage: $0 <pre|post>"
    exit ${eusage}
fi

if [ "${stage}" != "pre" ] && [ "${stage}" != "post" ]; then
    echo "Invalid arg: ${stage}"
    exit ${ebadstage}
fi

# log something to stdout
info "running success_sample_pre_post.sh"

if [ "${stage}" = "pre" ]; then
    prehook
    rc=$?
    if [ ${rc} -ne 0 ]; then
        error "Error during prehook"
    fi
fi

if [ "${stage}" = "post" ]; then
    posthook
    rc=$?
    if [ ${rc} -ne 0 ]; then
        error "Error during posthook"
    fi
fi

exit ${rc}
----

.Failure example
The following script demonstrates how you can handle failures in a hook.

[source,sh]
----

#!/bin/sh
#
# failure_sample_arg_exit_code.sh
#
# A simple failure hook script for testing purposes.
#
# args: [the exit code to return]
#


#
# Writes the given message to standard output
#
# $* - The message to write
#
msg() {
    echo "$*"
}


#
# Writes the given information message to standard output
#
# $* - The message to write
#
info() {
    msg "INFO: $*"
}

#
# Writes the given error message to standard error
#
# $* - The message to write
#
error() {
    msg "ERROR: $*" 1>&2
}


#
# main
#

# log something to stdout
info "running failure_sample_arg_exit_code.sh"

argexitcode=$1

# log to stderr
error "script failed, returning exit code ${argexitcode}"

# exit with specified exit code
exit ${argexitcode}
----

.Failure and then success example
The following script demonstrates a failure on the first run, but success on the second.

[source,sh]
----
#!/bin/sh
#
# failure_then_success_sample.sh
#
# A hook script that fails on initial run but succeeds on second run for testing purposes.
#
# Helpful for testing retry logic for post hooks.
#
# args: None
#

#
# Writes the given message to standard output
#
# $* - The message to write
#
msg() {
    echo "$*"
}


#
# Writes the given information message to standard output
#
# $* - The message to write
#
info() {
    msg "INFO: $*"
}

#
# Writes the given error message to standard error
#
# $* - The message to write
#
error() {
    msg "ERROR: $*" 1>&2
}


#
# main
#

# log something to stdout
info "running failure_success sample.sh"


if [ -e /tmp/hook-test.junk ] ; then
    info "File does exist.  Removing /tmp/hook-test.junk"
    rm /tmp/hook-test.junk
    info "Second run so returning exit code 0"
    exit 0
else
    info "File does not exist.  Creating /tmp/hook-test.junk"
    echo "test" > /tmp/hook-test.junk
    error "Failed first run, returning exit code 5"
    exit 5
fi
